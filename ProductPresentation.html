<!DOCTYPE html>
<html>
<head>
	<title>ProductPresentation</title>


<style>

body {
	font-family: Monospace;
	margin: 0px;
	overflow: hidden;
	/*background-color: #996000;*/
}

canvas {
	width: 100%;
	height: 100%;
}

#menu {
			position: absolute;
			bottom: 20px;
			width: 100%;
			padding: 10px;
			box-sizing: border-box;
			text-align: center;
		}

		button {
			color: rgb(255,255,255);
			background: rgb(255,255,255,0.1);
			border: 0px;
			padding: 5px 10px;
			margin: 2px;
			font-size: 14px;
			cursor: pointer;
		}

		button:hover {
				background-color: rgba(0,255,255,0.5);
			}

</style>

	</head>



<body>

		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>



<script type="text/x-glsl" id="vertex">
  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 wPosition;
  varying vec2 uVv;

  void main() {
    vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
    vPosition = vPos.xyz;
    wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
    vNormal = normalMatrix * normal;
    uVv = uv;
    gl_Position = projectionMatrix * vPos;
}
 </script>


<script type="text/x-glsl" id="fragment">

  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 wPosition;
  varying vec2 uVv;

  uniform vec3 pointLightPosition; // in world space
  uniform vec3 clight;

  uniform vec3 ambientLight;
  uniform sampler2D aoMap;

  uniform sampler2D specularMap;
  uniform sampler2D diffuseMap;
  uniform sampler2D roughnessMap;
  uniform vec2 textureRepeat;

  uniform sampler2D normalMap;
  uniform vec2 normalScale;


  uniform samplerCube envMap;

  const float PI = 3.14159;

  vec3 cdiff;
  vec3 cspec;
  float roughness;

  vec3 FSchlick(float lDoth) {
    return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
  }

  float DGGX(float nDoth, float alpha) {
    float alpha2 = alpha*alpha;
    float d = nDoth*nDoth*(alpha2-1.0)+1.0;
    return (  alpha2 / (PI*d*d));
  }

  float G1(float dotProduct, float k) {
    return (dotProduct / (dotProduct*(1.0-k) + k) );
  }

  float GSmith(float nDotv, float nDotl) {
      float k = roughness*roughness;
      return G1(nDotl,k)*G1(nDotv,k);
  }

  #extension GL_OES_standard_derivatives : enable

  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

  vec3 q0 = dFdx( eye_pos.xyz );
  vec3 q1 = dFdy( eye_pos.xyz );
  vec2 st0 = dFdx( uVv.st );
  vec2 st1 = dFdy( uVv.st );

  vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
  vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
  vec3 N =  surf_norm ;

  vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
  mapN.xy = normalScale * mapN.xy;
  mat3 tsn = mat3( S, T, N );
  return normalize( tsn * mapN );

}

  vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}

  void main() {


    vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
    vec3 l = normalize(lPosition.xyz - vPosition.xyz);
    vec3 n = perturbNormal2Arb( vPosition,normalize(vNormal));
    vec3 v = normalize( -vPosition);
    vec3 h = normalize( v + l);

    /*BRDF section*/
    // small quantity to prevent divisions by 0
    float nDotl = max(dot( n, l ),0.000001);
    float lDoth = max(dot( l, h ),0.000001);
    float nDoth = max(dot( n, h ),0.000001);
    float vDoth = max(dot( v, h ),0.000001);
    float nDotv = max(dot( n, v ),0.000001);

    cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
    // texture in sRGB, linearize
    cdiff = pow( cdiff, vec3(2.2));
    cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
    // texture in sRGB, linearize
    cspec = pow( cspec, vec3(2.2));
    roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

    vec3 fresnel = FSchlick(lDoth);
    vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/ (4.0*nDotl*nDotv);


    /* enviromentMapping section*/
    vec3 worldN = inverseTransformDirection( n, viewMatrix );
    vec3 worldV = cameraPosition - wPosition ;
    vec3 r = normalize( reflect(-worldV,worldN));

    vec3 irradiance = textureCube( envMap, worldN).rgb;
    // texture in sRGB, linearize
    irradiance = pow( irradiance, vec3(2.2));

    vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
    // texture in sRGB, linearize
    envLight = pow( envLight, vec3(2.2));

    vec3 outRadiance =  PI* clight * nDotl * BRDF
              +ambientLight*cdiff*texture2D( aoMap, uVv * textureRepeat ).xyz
              + cdiff*irradiance
              +fresnel*envLight;

    // gamma encode the final value
    gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
  }




</script>


<div id="menu"></div>

<script  type="module">


var scene, camera, renderer, controls, stats,actualPosition;
var menu = document.getElementById( "menu" );
var objects = [];
var Mesh, current, currentCube, type ,angle,prefer;
var light1,light2,light3,uniforms;

var BUTTONS = {
	"back":"Back",
	"heart":"AddPrefer",
	"shopping-cart": "AddToCart",
	"like": "AddLike",
	"rotate-right": "RotateLeft",
	"change": "changeTexture",
	"rotate-left": "RotateRight",
	"light-bulb-1":"Set1Light",
	"light-bulb-2":"Set2Light",
	"light-bulb-3":"Set3Light",
	"share": "Share",
	"next":"Next"
};


function Start() {

	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
	current = 0;
	objects = [];
	Mesh = ["DoubleBlades","Katana","Axe","SwordSting"];
	currentCube="Cave";
	type = 1;
	prefer = false;
	angle = 0;
	actualPosition= 25;


	renderer = new THREE.WebGLRenderer( {antialias: true} );
	renderer.setSize( window.innerWidth, window.innerHeight );

	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.gammaInput = true;
	renderer.gammaOutput = true;
	renderer.shadowMap.enabled = true;
	document.body.appendChild( renderer.domElement );

	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	document.body.appendChild( stats.domElement );

	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.enablePan = false;

	camera.position.z+= 20;


createMenu();

}



function objLoader(objectName,textureType,cubeMap,scaling){

		var vShader = document.getElementById("vertex").textContent;
		var fShader = document.getElementById("fragment").textContent;

		var specTxt = loadTexture("textures/Weapons/"+objectName+"Type"+textureType+"/Specular.png");
		var diffTxt = loadTexture("textures/Weapons/"+objectName+"Type"+textureType+"/Diffusive.png");
		var rougTxt = loadTexture("textures/Weapons/"+objectName+"Type"+textureType+"/Roughness.png");
		var normalTxtr = loadTexture("textures/Weapons/"+objectName+"Type"+textureType+"/Normal.png");
		var occlusionTxtr = loadTexture("textures/Weapons/"+objectName+"Type"+textureType+"/AmbientOcclusion.png");


		var cubeLoader = new THREE.CubeTextureLoader();
			cubeLoader.setPath('textures/CubeMaps/'+cubeMap+"/");
		var textureCube = cubeLoader.load( [
				'px.png', 'nx.png',
				'py.png', 'ny.png',
				'pz.png', 'nz.png'
			] );


			uniforms = {
			pointLightPosition:{type:"v3", value: new THREE.Vector3(5,5,5)}, // in world space
			clight:{type:"v3", value:new THREE.Vector3(1,1,1)},
			specularMap:{type:"t", value: specTxt},
			diffuseMap:{type:"t", value: diffTxt},
			roughnessMap:{type:"t", value: rougTxt},
			textureRepeat:{type:"v2", value:new THREE.Vector2(1,1)},
			normalMap:{type:"t", value: normalTxtr},
			normalScale:{type:"v2", value: new THREE.Vector2(2,2)},
			aoMap:{type:"t", value: occlusionTxtr},
			ambientLight:{type:"v3", value:new THREE.Vector3(0,0,0)},
			envMap:{type:"t", value: textureCube}

		}



		var shaderMat = new THREE.ShaderMaterial({
			uniforms: uniforms,
			fragmentShader: fShader ,
			vertexShader: vShader,
		});

		var loader = new THREE.OBJLoader();

		loader.load("Objects/"+objectName+".obj",function(obj){

					obj.children.forEach(writeGeometry);

					function writeGeometry(children){
						var geometry = children.geometry;
						var mesh = new THREE.Mesh( geometry, shaderMat );
						mesh.scale.set(scaling,scaling,scaling);
						// mesh.position.set(globalPosition.x,globalPosition.y,globalPosition.z);


						scene.add( mesh );
					 	objects.push(mesh);}
				});

		// uniforms.pointLightPosition.value = directedLight;
		// uniforms.ambientLight.value = ambientLight;

	}








function loadTexture(file) {
	var texture = new THREE.TextureLoader().load( file , function ( texture ) {

	texture.minFilter = THREE.LinearMipMapLinearFilter;
	texture.anisotropy = renderer.getMaxAnisotropy();
	texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.offset.set( 0, 0 );
	texture.needsUpdate = true;} )
	return texture;
		}


function createMenu() {

	for ( var i in BUTTONS ) {

		var button = document.createElement( 'button');
		button.setAttribute("id",BUTTONS[i]);
		button.innerHTML = '<img src="Icons/'+i+'.png" style="width:30px;height:30px;" >';
		menu.appendChild( button );
		button.addEventListener('click',buttonCallback(BUTTONS[i]),false);
	}
}




function buttonCallback(value) {

			// if(value=="Zoom"){
			//
		  //   return function () {
			//
			// 		actualPosition-=0.3;
			// 		camera.position.z = actualPosition*Math.cos(angle);
			//
			// 		camera.position.x = actualPosition*Math.sin(angle);
			//
			// 	}
			//
		  // }else if(value=="BackZoom"){
			//
			// 	return function () {
			//
			// 		actualPosition+=0.3;
			// 		camera.position.z = actualPosition*Math.cos(angle);
			// 		camera.position.x = actualPosition*Math.sin(angle);
			//
			// 	}
			//
			//
		  // }else

			if(value=="RotateRight"){

				return function () {

					if(angle>=360){angle = 0}else{angle+=1;};
					camera.position.x = actualPosition*Math.sin(angle);
					camera.position.z = actualPosition*Math.cos(angle);
					camera.lookAt(0,0,0);
				}

		  }else if(value=="RotateLeft"){

					return function () {
						if(angle<=0){angle = 360}else{angle-=1;};
						camera.position.x = actualPosition*Math.sin(angle);
						camera.position.z = actualPosition*Math.cos(angle);
						camera.lookAt(0,0,0);
				}

		  }else if(value=="AddLike"){

				return function(){
						alert("Need to associate a facebook account to unlock this feature");
					}

		  }else if(value=="AddPrefer"){

				return function () {
					if (prefer){

						var strMessage1 = document.getElementById("AddPrefer") ;

						strMessage1.innerHTML = strMessage1.innerHTML.replace(/./g, '');
						strMessage1.innerHTML = ' ';
						strMessage1.innerHTML = strMessage1.innerHTML.replace(/ /g, '<img src="Icons/heart.png" style="width:30px;height:30px">');
						prefer = false;

					}else{
						var strMessage1 = document.getElementById("AddPrefer") ;
						strMessage1.innerHTML = strMessage1.innerHTML.replace(/./g, ' ');
						strMessage1.innerHTML = ' ';
						strMessage1.innerHTML = strMessage1.innerHTML.replace(/ /g, '<img src="Icons/heartOn.png" style="width:30px;height:30px">');

						prefer = true;

					}

				}

		  }else if(value=="Set2Light"){

				return function () {}

		  }else if(value=="Set3Light"){

				return function () {}

		  }else if(value=="Set1Light"){

				return function () {
					uniforms.ambientLight.value= new THREE.Vector3(2,2,2);
				}

		  }else if(value=="Back"){
				return function(){

					if(current==0){
						 current=3;
					 }else{
						 current--; };

						for ( var i = 0; i < objects.length; i ++ ) {
							 var object = objects[ i ];
							 object.remove( object );
							 scene.remove( object );
						 };
						 var pointer = Mesh[current];
						 OBJ(pointer);
						 camera.position.set(0,0,25);
						 camera.lookAt(0,0,0);
					 }

			}else if(value=="Next"){

				return function(){
					if(current==3){
		        current=0;
		      }else{
		        current++; };


		        for ( var i = 0; i < objects.length; i ++ ) {
		          var object = objects[ i ];

		          object.remove( object );
		          scene.remove( object );
		        };

		      var pointer = Mesh[current];

					OBJ(pointer);
					camera.position.set(0,0,25);
					camera.lookAt(0,0,0);

		      }

			}else if(value=="Share"){

				return function(){
						alert("This function will be avaiable soon!");
					}

		  }else if(value=="AddToCart"){

				return function(){
					  alert("Sorry at moment our server are busy, try later");
					}

		  }else if(value=="changeTexture"){

				return function(){

				if(type==1){
					type=2;
				}else{
					type=1;
				}

				for ( var i = 0; i < objects.length; i ++ ) {
					var object = objects[ i ];

					object.remove( object );
					scene.remove( object );
				};

			var pointer = Mesh[current];

			OBJ(pointer);
		};
	}
}






function Animate() {
		requestAnimationFrame( Animate );
		renderer.render( scene, camera );
		stats.update();
		controls.update();
}


function OBJ(objectName){
	if(objectName=="DoubleBlades"){
		objLoader(objectName,type,currentCube,0.3);
	}else if(objectName=="Katana"){
		objLoader(objectName,type,currentCube,0.9);
	}else if(objectName=="Axe"){
		objLoader(objectName,type,currentCube,1);
	}else if(objectName=="SwordSting"){
		objLoader(objectName,type,currentCube,1);
	}
}


Start();
Animate();

</script>


	</body>
</html>
