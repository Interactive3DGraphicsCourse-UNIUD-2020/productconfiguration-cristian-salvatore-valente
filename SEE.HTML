<!DOCTYPE html>
<html>
precision highp float;

uniform bool uUsePositionLighting;
uniform bool uUseDirectionalLighting;

uniform vec3 uLightPosition;
uniform vec3 uLightDirection;

uniform vec3 uAmbientColor;
uniform vec3 uDirectionalColor;

uniform float uAlpha;

varying vec4 vPosition;
varying vec3 vTransformedNormal;
varying vec3 vColor;


void main(void) {
   vec3 reflectedLightColor;

   // Calculate incoming light for all light sources
   for(int i = 0; i < 16; i++) {
     vec3 lightDirection = normalize(uLightPosition[i], vPosition.xyz);
     if (lightIsDirectional[i]) {
       reflectedLightColor += max(dot(vTransformedNormal, uLightDirection[i]), 0.0) * uLightColor[i];
     }
     else  {
       reflectedLightColor += max(dot(normalize(vTransformedNormal, lightDirection), 0.0) * uLightColor[i];
     }
   }

   glFragColor = vec4(uAmbientColor + reflectedLightColor * vColor, uAlpha);
 }

 <script> //good fragment

   varying vec3 vNormal;
   varying vec3 vPosition;
   varying vec3 wPosition;
   varying vec2 uVv;

   uniform vec3 pointLightPosition; // in world space
   uniform vec3 clight;

   uniform vec3 ambientLight;
   uniform sampler2D aoMap;

   uniform sampler2D specularMap;
   uniform sampler2D diffuseMap;
   uniform sampler2D roughnessMap;
   uniform vec2 textureRepeat;

   uniform sampler2D normalMap;
   uniform vec2 normalScale;


   uniform samplerCube envMap;

   const float PI = 3.14159;

   vec3 cdiff;
   vec3 cspec;
   float roughness;

   vec3 FSchlick(float lDoth) {
     return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
   }

   float DGGX(float nDoth, float alpha) {
     float alpha2 = alpha*alpha;
     float d = nDoth*nDoth*(alpha2-1.0)+1.0;
     return (  alpha2 / (PI*d*d));
   }

   float G1(float dotProduct, float k) {
     return (dotProduct / (dotProduct*(1.0-k) + k) );
   }

   float GSmith(float nDotv, float nDotl) {
       float k = roughness*roughness;
       return G1(nDotl,k)*G1(nDotv,k);
   }

   #extension GL_OES_standard_derivatives : enable

   vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

   vec3 q0 = dFdx( eye_pos.xyz );
   vec3 q1 = dFdy( eye_pos.xyz );
   vec2 st0 = dFdx( uVv.st );
   vec2 st1 = dFdy( uVv.st );

   vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
   vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
   vec3 N =  surf_norm ;

   vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
   mapN.xy = normalScale * mapN.xy;
   mat3 tsn = mat3( S, T, N );
   return normalize( tsn * mapN );

 }

   vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
 }

   void main() {


     vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
     vec3 l = normalize(lPosition.xyz - vPosition.xyz);
     vec3 n = perturbNormal2Arb( vPosition,normalize(vNormal));
     vec3 v = normalize( -vPosition);
     vec3 h = normalize( v + l);

     /*BRDF section*/
     // small quantity to prevent divisions by 0
     float nDotl = max(dot( n, l ),0.000001);
     float lDoth = max(dot( l, h ),0.000001);
     float nDoth = max(dot( n, h ),0.000001);
     float vDoth = max(dot( v, h ),0.000001);
     float nDotv = max(dot( n, v ),0.000001);

     cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
     // texture in sRGB, linearize
     cdiff = pow( cdiff, vec3(2.2));
     cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
     // texture in sRGB, linearize
     cspec = pow( cspec, vec3(2.2));
     roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

     vec3 fresnel = FSchlick(lDoth);
     vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI +
 								fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/ (4.0*nDotl*nDotv);


     /* enviromentMapping section*/
     vec3 worldN = inverseTransformDirection( n, viewMatrix );
     vec3 worldV = cameraPosition - wPosition ;
     vec3 r = normalize( reflect(-worldV,worldN));

     vec3 irradiance = textureCube( envMap, worldN).rgb;
     // texture in sRGB, linearize
     irradiance = pow( irradiance, vec3(2.2));

     vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
     // texture in sRGB, linearize
     envLight = pow( envLight, vec3(2.2));

     vec3 outRadiance =  PI* clight * nDotl * BRDF
               +ambientLight*cdiff*texture2D( aoMap, uVv * textureRepeat ).xyz
               + cdiff*irradiance
               +fresnel*envLight;

     // gamma encode the final value
     gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
   }
 </script>
 </html>
